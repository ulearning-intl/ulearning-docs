import { Callout } from 'nextra-theme-docs'

# 与Next.js一起使用 

## 应用程序路由器 [#app-dir]

### 服务器组件 [#rsc]


<Callout type="default" emoji="✅">
  在Next.js App Router中，默认情况下，所有组件都是React Server组件（RSC）。**您只能从RSC中的SWR导入密钥序列化API**
</Callout>

```tsx filename="app/page.tsx" copy
import { unstable_serialize } from 'swr' // ✅ Available in server components
import { unstable_serialize as infinite_unstable_serialize } from 'swr/infinite' // ✅ Available in server components
```

<Callout type="error">
   您无法从SWR导入任何其他API，因为它们在RSC中不可用。
</Callout>

```tsx filename="app/page.tsx" highlight={1}
import useSWR from 'swr' // ❌ This is not available in server components
```

### 客户端组件

您可以使用'使用客户端'指令标记组件，或从客户端组件导入SWR，这两种方式都允许您使用SWR客户端数据获取钩子。

```tsx filename="app/page.tsx" highlight={1} copy
'use client'
import useSWR from 'swr'
export default Page() {
  const { data } = useSWR('/api/user', fetcher)
  return <h1>{data.name}</h1>
}
```

如果您需要使用“SWRConfig”在服务器组件'布局'或'页面'中配置全局设置，请创建一个单独的提供商客户端组件来设置提供商和配置，然后在服务器组件页面中使用它。

```tsx filename="app/swr-provider.tsx" copy
'use client';
import { SWRConfig } from 'swr'
export const SWRProvider = ({ children }) => {
  return <SWRConfig>{children}</SWRConfig>
};
```

```tsx filename="app/page.tsx" copy
// This is still a server component
import { SWRProvider } from './swr-provider'
export default Page() {
  return (
    <SWRProvider>
      <h1>hello SWR</h1>
    </SWRProvider>
  )
}
```


## 客户端数据取取[#客户端数据取] 

如果您的页面包含频繁更新的数据，并且您不需要预渲染数据，那么SWR非常适合，不需要特殊设置：只需导入`useSWR`并使用任何使用数据的组件内的钩子即可。 
 
以下是它的工作原理： 
 
-首先，立即显示没有数据的页面。 您可以显示丢失数据的加载状态。 
- 然后，在客户端获取数据，准备好后显示。 

例如，这种方法适用于用户仪表板页面。 由于仪表板是一个私人的、特定于用户的页面，SEO无关紧要，页面不需要预渲染。 数据经常更新，这需要在请求时获取数据。 

## 默认数据预渲染[#默认数据预渲染] 
 
如果页面必须预渲染，Next.js支持[2种预渲染形式]（https://nextjs.org/docs/basic-features/data-fetching）： 
**静态生成（SSG）**和**服务器端渲染（SSR）**。 
 
与SWR一起，您可以为SEO预渲染页面，还具有诸如归种、重新validation、焦点跟踪、客户端间隔重新获取等功能。 
 
您可以使用[`SWRConfig`](/docs/global-configuration)的`fallback`选项将预获取的数据作为所有SWR钩子的初始值传递。 
 
例如`getStaticProps`：

```jsx
 export async function getStaticProps () {
  // `getStaticProps` is executed on the server side.
  const article = await getArticleFromAPI()
  return {
    props: {
      fallback: {
        '/api/article': article
      }
    }
  }
}

function Article() {
  // `data` will always be available as it's in `fallback`.
  const { data } = useSWR('/api/article', fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  // SWR hooks inside the `SWRConfig` boundary will use those values.
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```

该页面仍处于预渲染中。 它对SEO友好，响应迅速，但也完全由客户端的SWR提供支持。 数据可以随着时间的推移进行动态和自我更新。

<Callout emoji="💡">
  `文章`组件将首先呈现预生成的数据，在页面水合后，它将再次获取最新数据以保持刷新。
</Callout>

### 复杂键 [#complex-keys]

`useSWR`可以与`array`和`function`类型的键一起使用。使用此类密钥使用预获取数据需要使用`unstable_serialize`对`fallback`密钥进行序列化。

```jsx
import useSWR, { unstable_serialize } from 'swr'

export async function getStaticProps () {
  const article = await getArticleFromAPI(1)
  return {
    props: {
      fallback: {
        // unstable_serialize() array style key
        [unstable_serialize(['api', 'article', 1])]: article,
      }
    }
  }
}

function Article() {
  // using an array style key.
  const { data } = useSWR(['api', 'article', 1], fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```
