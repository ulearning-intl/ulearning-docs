import Video from 'components/video'
import { Callout } from 'nextra-theme-docs'
import { Bleed } from 'nextra-theme-docs'
import Link from 'next/link'

机翻

# إعادة التحقق التلقائي

<Callout>
  إذا كنت ترغب في إعادة التحقق من البيانات يدويا، فتحقق من <Link href="/docs/mutation">طَفْرة</Link>.
</Callout>

## إعادة التحقق من التركيز [#revalidate-on-focus] 

عند إعادة تركيز صفحة أو التبديل بين علامات التبويب، تقوم SWR بإعادة التحقق من البيانات تلقائيا. 

قد يكون هذا مفيدا للمزامنة على الفور مع أحدث حالة. هذا مفيد لتحديث البيانات في سيناريوهات مثل علامات تبويب الهواتف المحمولة القديمة، أو أجهزة الكمبيوتر المحمولة التي **ذهبت إلى النوم **.

<Bleed>
  <Video
    src="https://raw.githubusercontent.com/vercel/swr-site/master/.github/videos/focus-revalidate.mp4"
    caption="فيديو: استخدام إعادة التحقق من صحة التركيز لمزامنة حالة تسجيل الدخول تلقائيا بين الصفحات."
    ratio={307/768}
    className="mx-8 2xl:mx-24"
/>
</Bleed>

يتم تمكين هذه الميزة افتراضيا. يمكنك تعطيله عبر خيار [`revalidateOnFocus`](/docs/api). رقم 

## إعادة التحقق من الصحة على الفاصل الزمني  رقم [#revalidate-on-interval]

في كثير من الحالات، تتغير البيانات بسبب أجهزة متعددة، ومستخدمين متعددين، وعلامات تبويب متعددة. كيف يمكننا مع مرور الوقت تحديث البيانات على الشاشة؟ رقم 
 
ستمنحك SWR خيار إعادة مسح البيانات تلقائيا. إنه **ذكي** مما يعني أن إعادة الجلب لن تحدث إلا إذا كان المكون المرتبط بالخطاف **على الشاشة**.

<Bleed>
  <Video
    src="https://raw.githubusercontent.com/vercel/swr-site/master/.github/videos/refetch-interval.mp4"
    caption="فيديو: عندما يقوم المستخدم بإجراء تغيير، ستقدم كلتا الجلستين في النهاية نفس البيانات."
    ratio={307/768}
    className="mx-8 2xl:mx-24"
  />
</Bleed>

يمكنك تمكينه عن طريق تعيين قيمة [`refreshInterval`](/docs/api):

```js
useSWR('/api/todos', fetcher, { refreshInterval: 1000 })
```

هناك أيضا خيارات مثل `refreshWhenHidden` و`refreshWhenOffline`. يتم تعطيل كليهما افتراضيا حتى لا تجلب SWR عندما لا تكون صفحة الويب على الشاشة، أو لا يوجد اتصال بالشبكة. 
 
## إعادة التحقق من صالح إعادة الاتصال [#revalidate-on-reconnect] 
 
من المفيد أيضا إعادة التحقق من أنه عند عودة المستخدم إلى الإنترنت. يحدث هذا السيناريو كثيرا عندما يفتح المستخدم جهاز الكمبيوتر الخاص به، ولكن الإنترنت غير متصل بعد في نفس اللحظة. 
 
للتأكد من تحديث البيانات دائما، تتم إعادة التحقق من صحة SWR تلقائيا عند استرداد الشبكة. 
 
يتم تمكين هذه الميزة افتراضيا. يمكنك تعطيله عبر الخيار [`revalidateOnReconnect`](/docs/api). 
 
## تعطيل عمليات التحقق التلقائية [#disable-automatic-revalidations] 
 
إذا كان المورد **غير قابل للتغيير**، فلن يتغير ذلك أبدا إذا قمنا بإعادة التحقق مرة أخرى، فيمكننا تعطيل جميع أنواع عمليات إعادة التحقق التلقائية له. 
 
منذ الإصدار 1.0، يوفر SWR خطاف مساعد `useSWRImmutable` لوضع علامة على المورد على أنه غير قابل للتغيير:

```js
import useSWRImmutable from 'swr/immutable'

// ...
useSWRImmutable(key, fetcher, options)
```

يحتوي على نفس واجهة واجهة برمجة التطبيقات مثل خطاف `useSWR` العادي. يمكنك أيضا القيام بنفس الشيء عن طريق تعطيل خيارات إعادة التحقق التالية:

```js
useSWR(key, fetcher, {
  revalidateIfStale: false,
  revalidateOnFocus: false,
  revalidateOnReconnect: false
})

// equivalent to
useSWRImmutable(key, fetcher)
```

يتحكم `revalidateIfStale` في ما إذا كان يجب إعادة التحقق من SWR عند تحميله وهناك بيانات قديمة. 

هذان الخطافان أعلاه يفعلان الشيء **بالضبط**. بمجرد تخزين البيانات مؤقتا، لن يطلبوها مرة أخرى. 

## إعادة التحقق من صالح على جبل[#إعادة التحقق من صالح على جبل] 
 
من المفيد فرض تجاوز إعادة التحقق من SWR عند التركيب. بشكل افتراضي، يتم تعيين قيمة `revalidateOnMount` على غير محددة. 

يتصاعد خطاف SWR على النحو التالي: 
 
- يتحقق أولا مما إذا كان `revalidateOnMount` محددا. يبدأ الطلب إذا كان صحيحا، توقف إذا كان خاطئا. 
 
`revalidateIfStale` مفيد للتحكم في سلوك التثبيت. بشكل افتراضي، يتم تعيين `revalidateIfStale` على true. 
 
إذا تم تعيين `revalidateIfStale` على true، فسيتم إعادة إدخاله فقط إذا كانت هناك أي بيانات ذاكرة تخزين مؤقت أخرى، فلن يتم إعادة جلبها.
