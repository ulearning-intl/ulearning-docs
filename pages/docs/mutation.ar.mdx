import { Callout } from 'nextra-theme-docs'

机翻

# الطفرة وإعادة التحقق من صحة 

توفر SWR واجهات برمجة تطبيقات [`mutate`](/docs/mutation#mutate) و[`useSWRMutation`](/docs/mutation#useswrmutation) لتحور البيانات عن بعد وذاكرة التخزين المؤقت ذات الصلة. 
 
## `mutate` [#mutate] 
 
هناك طريقتان لاستخدام واجهة برمجة تطبيقات `mutate` لتحور البيانات، وواجهة برمجة التطبيقات العالمية التي يمكنها تحويل أي مفتاح وواجهة برمجة تطبيقات التحور المقيدة التي يمكنها فقط تحويل بيانات خطاف SWR المقابل. 
 
#### طفرة عالمية [#تحول عالمي] 

الطريقة الموصى بها للحصول على الطفر العالمي هي استخدام خطاف [`useSWRConfig`](/docs/global-configuration#access-to-global-configurations):

```js
import { useSWRConfig } from "swr"

function App() {
  const { mutate } = useSWRConfig()
  mutate(key, data, options)
}
```

يمكنك أيضا استيراده عالميا:

```js
import { mutate } from "swr"

function App() {
  mutate(key, data, options)
}
```

<Callout emoji="⚠️">
  لن يؤدي استخدام المتحور العالمي فقط مع معلمة `key` *** إلى تحديث ذاكرة التخزين المؤقت أو تشغيل إعادة التحقق من الصحة *** ما لم يكن هناك خطاف SWR مثبت باستخدام نفس المفتاح.
</Callout>

#### تحور مقيد [#تحور ملزم] 

الطفرة الم ملزمة هي المسار القصير لتحور المفتاح الحالي بالبيانات. أي `key` مرتبط ب `key` يمر إلى `useSWR`، ويتلقى `data` كوسيطة أولى. 
 
 إنه يعادل وظيفيا الدالة `mutate` العالمية في القسم السابق ولكنه لا يتطلب المعلمة `key`:

```jsx
import useSWR from 'swr'

function Profile () {
  const { data, mutate } = useSWR('/api/user', fetcher)

  return (
    <div>
      <h1>My name is {data.name}.</h1>
      <button onClick={async () => {
        const newName = data.name.toUpperCase()
        // send a request to the API to update the data
        await requestUpdateUsername(newName)
        // update the local data immediately and revalidate (refetch)
        // NOTE: key is not required when using useSWR's mutate as it's pre-bound
        mutate({ ...data, name: newName })
      }}>Uppercase my name!</button>
    </div>
  )
}
```

#### إعادة التحقق من صحة [#إعادة التحقق] 

عند استدعاء `mutate(key)` (أو مجرد `mutate()` مع واجهة برمجة تطبيقات التحور المقيدة) دون أي بيانات، سيؤدي ذلك إلى إعادة التحقق من صحة (قم بوضع علامة على البيانات على أنها منتهية الصلاحية وقم بتشغيل إعادة الجلب) 
من أجل المورد. يوضح هذا المثال كيفية إعادة جلب معلومات تسجيل الدخول تلقائيا (على سبيل المثال داخل ``) 
عندما ينقر المستخدم على زر "تسجيل الخروج":

```jsx {14}
import useSWR, { useSWRConfig } from 'swr'

function App () {
  const { mutate } = useSWRConfig()

  return (
    <div>
      <Profile />
      <button onClick={() => {
        // set the cookie as expired
        document.cookie = 'token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'

        // tell all SWRs with this key to revalidate
        mutate('/api/user')
      }}>
        Logout
      </button>
    </div>
  )
}
```

<Callout>
يبث إلى خطافات SWR تحت نفس نطاق [مزود ذاكرة التخزين المؤقت] (/docs/advanced/cache). في حالة عدم وجود مزود ذاكرة التخزين المؤقت، فسيتم بثه إلى جميع خطافات SWR.
</Callout>

### واجهة برمجة التطبيقات  رقم [#api]

#### المعلمات [#المعلمات]


 - `key`: نفس `useSWR`'s `key`، ولكن الوظيفة تتصرف ك [وظيفة تصفية] (/docs/mutation#mutate-multiple-items) رقم 
 - `data`: بيانات لتحديث ذاكرة التخزين المؤقت للعميل، أو وظيفة غير متزامنة للطفرة عن بعد رقم 
 - `options`: يقبل الخيارات التالية رقم 
   - `optimisticData`: بيانات لتحديث ذاكرة التخزين المؤقت للعميل على الفور، أو وظيفة تتلقى البيانات الحالية وتعيد بيانات ذاكرة التخزين المؤقت للعميل الجديدة، وعادة ما تستخدم في واجهة المستخدم المتفائلة. رقم 
   - `revalidate = true`: إذا تم إعادة التحقق من صحة ذاكرة التخزين المؤقت بمجرد حل التحديث غير المتزامن. رقم 
   - `populateCache = true`: هل يجب كتابة نتيجة الطفرة عن بعد إلى ذاكرة التخزين المؤقت، أو وظيفة تتلقى نتيجة جديدة ونتيجة حالية كحجج وتعيد نتيجة الطفرة. رقم 
   - `rollbackOnError = true`: هل يجب على ذاكرة التخزين المؤقت التراجع إذا كانت أخطاء الطفرة عن بعد، أو وظيفة تتلقى الخطأ الذي تم طرحه من fetcher كحجج وإرجاع منطقي سواء كان يجب التراجع أم لا. رقم 
   - `throwOnError = true`: إذا كانت المكالمة المتحورة ترمي الخطأ عند فشلها.

#### Return Values [#return-values]

`mutate` returns the results the `data` parameter has been resolved. The function passed to `mutate` will return an updated data which is used to update the corresponding cache value. If there is an error thrown while executing the function, the error will be thrown so it can be handled appropriately.

```jsx
try {
  const user = await mutate('/api/user', updateUser(newUser))
} catch (error) {
  // Handle an error while updating the user here
}
```

## `useSWRMutation` [#useswrmutation]

SWR also provides `useSWRMutation` as a hook for remote mutations. The remote mutations are only triggered manually, instead of automatically like `useSWR`.

Also, this hook doesn’t share states with other `useSWRMutation` hooks.

```tsx
import useSWRMutation from 'swr/mutation'

// Fetcher implementation.
// The extra argument will be passed via the `arg` property of the 2nd parameter.
// In the example below, `arg` will be `'my_token'`
async function updateUser(url, { arg }: { arg: string }) {
  await fetch(url, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${arg}`
    }
  })
}

function Profile() {
  // A useSWR + mutate like API, but it will not start the request automatically.
  const { trigger } = useSWRMutation('/api/user', updateUser, options)

  return <button onClick={() => {
    // Trigger `updateUser` with a specific argument.
    trigger('my_token')
  }}>Update User</button>
}
```

### API [#useswrmutation-api]

#### Parameters [#useswrmutation-parameters]

- `key`: same as [`mutate`](/docs/mutation#mutate)'s `key`
- `fetcher(key, { arg })`: an async function for remote mutation
- `options`: an optional object with the following properties:
  - `optimisticData`: same as `mutate`'s `optimisticData`
  - `revalidate = true`: same as `mutate`'s `revalidate`
  - `populateCache = false`: same as `mutate`'s `populateCache`, but the default is `false`
  - `rollbackOnError = true`: same as `mutate`'s `rollbackOnError`
  - `throwOnError = true`: same as `mutate`'s `throwOnError`
  - `onSuccess(data, key, config)`:　 callback function when a remote mutation has been finished successfully
  - `onError(err, key, config)`: callback function when a remote mutation has returned an error

#### Return Values [#useswrmutation-return-values]

- `data`: data for the given key returned from `fetcher`
- `error`: error thrown by `fetcher` (or undefined)
- `trigger(arg, options)`: a function to trigger a remote mutation
- `reset`: a function to reset the state (`data`, `error`, `isMutating`)
- `isMutating`: if there's an ongoing remote mutation

### Basic Usage [#useswrmutation-basic-usage]

```tsx
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }: { arg: { username: string }}) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  }).then(res => res.json())
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest, /* options */)

  return (
    <button
      disabled={isMutating}
      onClick={async () => {
        try {
          const result = await trigger({ username: 'johndoe' }, /* options */)
        } catch (e) {
          // error handling
        }
      }}
    >
      Create User
    </button>
  )
}
```

If you want to use the mutation results in rendering, you can get them from the return values of `useSWRMutation`.

```jsx
const { trigger, data, error } = useSWRMutation('/api/user', sendRequest)
```

`useSWRMutation` shares a cache store with `useSWR`, so it can detect and avoid race conditions between `useSWR`. It also supports `mutate`'s functionalities like optimistic updates and rollback on errors. You can pass these options `useSWRMutation` and its `trigger` function.

```jsx
const { trigger } = useSWRMutation('/api/user', updateUser, {
  optimisticData: current => ({ ...current, name: newName })
})

// or

trigger(newName, {
  optimisticData: current => ({ ...current, name: newName })
})
```

### Defer loading data until needed [#defer-loading-data-until-needed]

You can also use `useSWRMutation` for loading data. `useSWRMutation` won't start requesting until `trigger` is called, so you can defer loading data when you actually need it.

```jsx
import { useState } from 'react'
import useSWRMutation from 'swr/mutation'

const fetcher = url => fetch(url).then(res => res.json())

const Page = () => {
  const [show, setShow] = useState(false)
  // data is undefined until trigger is called
  const { data: user, trigger } = useSWRMutation('/api/user', fetcher);

  return (
    <div>
      <button onClick={() => {
        trigger();
        setShow(true);
      }}>Show User</button>
      {show && user ? <div>{user.name}</div> : null}
    </div>
  );
}
```

## Optimistic Updates [#optimistic-updates]

In many cases, applying local mutations to data is a good way to make changes
feel faster — no need to wait for the remote source of data.

With the `optimisticData` option, you can update your local data manually, while
waiting for the remote mutation to finish. Composing `rollbackOnError` you can also
control when to rollback the data.

```jsx
import useSWR, { useSWRConfig } from 'swr'

function Profile () {
  const { mutate } = useSWRConfig()
  const { data } = useSWR('/api/user', fetcher)

  return (
    <div>
      <h1>My name is {data.name}.</h1>
      <button onClick={async () => {
        const newName = data.name.toUpperCase()
        const user = { ...data, name: newName }
        const options = {
          optimisticData: user,
          rollbackOnError(error) {
            // If it's timeout abort error, don't rollback
            return error.name !== 'AbortError'
          },
        }

        // updates the local data immediately
        // send a request to update the data
        // triggers a revalidation (refetch) to make sure our local data is correct
        mutate('/api/user', updateFn(user), options);
      }}>Uppercase my name!</button>
    </div>
  )
}
```

> The **`updateFn`** should be a promise or asynchronous function to handle the remote mutation, it should return updated data.

You can also pass a function to `optimisticData` to make it depending on the current data:

```jsx
import useSWR, { useSWRConfig } from 'swr'

function Profile () {
  const { mutate } = useSWRConfig()
  const { data } = useSWR('/api/user', fetcher)

  return (
    <div>
      <h1>My name is {data.name}.</h1>
      <button onClick={async () => {
        const newName = data.name.toUpperCase()
        mutate('/api/user', updateUserName(newName), {
          optimisticData: user => ({ ...user, name: newName }),
          rollbackOnError: true
        });
      }}>Uppercase my name!</button>
    </div>
  )
}
```

You can also create the same thing with `useSWRMutation` and `trigger`:

```jsx
import useSWRMutation from 'swr/mutation'

function Profile () {
  const { trigger } = useSWRMutation('/api/user', updateUserName)

  return (
    <div>
      <h1>My name is {data.name}.</h1>
      <button onClick={async () => {
        const newName = data.name.toUpperCase()

        trigger(newName, {
          optimisticData: user => ({ ...user, name: newName }),
          rollbackOnError: true
        })
      }}>Uppercase my name!</button>
    </div>
  )
}
```

## Rollback on Errors [#rollback-on-errors]

When you have `optimisticData` set, it’s possible that the optimistic data gets
displayed to the user, but the remote mutation fails. In this case, you can leverage
`rollbackOnError` to revert the local cache to the previous state, to make sure
the user is seeing the correct data.

## Update Cache After Mutation [#update-cache-after-mutation]

Sometimes, the remote mutation request directly returns the updated data, so there is no need to do an extra fetch to load it.
You can enable the `populateCache` option to update the cache for `useSWR` with the response of the mutation:

```jsx
const updateTodo = () => fetch('/api/todos/1', {
  method: 'PATCH',
  body: JSON.stringify({ completed: true })
})

mutate('/api/todos', updateTodo, {
  populateCache: (updatedTodo, todos) => {
    // filter the list, and return it with the updated item
    const filteredTodos = todos.filter(todo => todo.id !== '1')
    return [...filteredTodos, updatedTodo]
  },
  // Since the API already gives us the updated information,
  // we don't need to revalidate here.
  revalidate: false
})
```

Or with the `useSWRMutation` hook:

```jsx
useSWRMutation('/api/todos', updateTodo, {
  populateCache: (updatedTodo, todos) => {
    // filter the list, and return it with the updated item
    const filteredTodos = todos.filter(todo => todo.id !== '1')
    return [...filteredTodos, updatedTodo]
  },
  // Since the API already gives us the updated information,
  // we don't need to revalidate here.
  revalidate: false
})
```

When combined with `optimisticData` and `rollbackOnError`, you’ll get a perfect optimistic UI experience.

## Avoid Race Conditions [#avoid-race-conditions]

Both `mutate` and `useSWRMutation` can avoid race conditions between `useSWR`. For example,

```tsx
function Profile() {
  const { data } = useSWR('/api/user', getUser, { revalidateInterval: 3000 })
  const { trigger } = useSWRMutation('/api/user', updateUser)

  return <>
    {data ? data.username : null}
    <button onClick={() => trigger()}>Update User</button>
  </>
}
```

The normal `useSWR` hook might refresh its data any time due to focus, polling, or other conditions. This way the displayed username
can be as fresh as possible. However, since we have a mutation there that can happen at the nearly same time of a refetch of `useSWR`, there
could be a race condition that `getUser` request starts earlier, but takes longer than `updateUser`.

Luckily, `useSWRMutation` handles this for you automatically. After the mutation, it will tell `useSWR` to ditch the ongoing request and revalidate,
so the stale data will never be displayed.

## Mutate Based on Current Data [#mutate-based-on-current-data]

Sometimes, you want to update a part of your data based on the current data.

With `mutate`, you can pass an async function which will receive the current cached value, if any, and returns an updated document.

```jsx
mutate('/api/todos', async todos => {
  // let's update the todo with ID `1` to be completed,
  // this API returns the updated data
  const updatedTodo = await fetch('/api/todos/1', {
    method: 'PATCH',
    body: JSON.stringify({ completed: true })
  })

  // filter the list, and return it with the updated item
  const filteredTodos = todos.filter(todo => todo.id !== '1')
  return [...filteredTodos, updatedTodo]
// Since the API already gives us the updated information,
// we don't need to revalidate here.
}, { revalidate: false })
```

## Mutate Multiple Items [#mutate-multiple-items]

The global `mutate` API accepts a filter function, which accepts `key` as the argument and returns which keys to revalidate. The filter function is applied to all the existing cache keys:

```jsx
import { mutate } from 'swr'
// Or from the hook if you customized the cache provider:
// { mutate } = useSWRConfig()

mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: true }
)
```

This also works with any key type like an array. The mutation matches all keys, of which the first element is `'item'`.

```jsx
useSWR(['item', 123], ...)
useSWR(['item', 124], ...)
useSWR(['item', 125], ...)

mutate(
  key => Array.isArray(key) && key[0] === 'item',
  undefined,
  { revalidate: false }
)
```

The filter function is applied to all existing cache keys, so you should not assume the shape of keys when using multiple shapes of keys.

```jsx
// ✅ matching array key
mutate((key) => key[0].startsWith('/api'), data)
// ✅ matching string key
mutate((key) => typeof key === 'string' && key.startsWith('/api'), data)

// ❌ ERROR: mutate uncertain keys (array or string)
mutate((key: any) => /\/api/.test(key.toString()))
```

You can use the filter function to clear all cache data, which is useful when logging out:

```js
const clearCache = () => mutate(
  () => true,
  undefined,
  { revalidate: false }
)

// ...clear cache on logout
clearCache()
```
