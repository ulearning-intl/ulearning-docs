# الأداء رقم 

يوفر SWR وظائف حاسمة في جميع أنواع تطبيقات الويب، لذلك **الأداء** هو أولوية قصوى. رقم 
 
يتخطى **التخزين المؤقت المدمج في SWR** و **[deduplication](#deduplication)** طلبات الشبكة غير الضرورية، ولكن رقم 
لا يزال أداء خطاف "useSWR" نفسه مهما. في تطبيق معقد، يمكن أن يكون هناك المئات من مكالمات `useSWR` في عرض صفحة واحدة. رقم 
 
يضمن SWR أن تطبيقك يحتوي على: رقم 
 
- _لا توجد طلبات غير ضرورية_ رقم 
- _لا توجد إعادة تقديم غير ضرورية_ رقم 
- _لا يوجد رمز غير ضروري مستورد_ رقم 
 
بدون أي تغييرات في التعليمات البرمجية منك.

## إلغاء التكرار [# إلغاء التكرار] رقم 

من الشائع جدا إعادة استخدام خطافات SWR في تطبيقك. على سبيل المثال، تطبيق يعرض الصورة الرمزية للمستخدم الحالي 5 مرات:

```jsx
function useUser () {
  return useSWR('/api/user', fetcher)
}

function Avatar () {
  const { data, error } = useUser()

  if (error) return <Error />
  if (!data) return <Spinner />

  return <img src={data.avatar_url} />
}

function App () {
  return <>
    <Avatar />
    <Avatar />
    <Avatar />
    <Avatar />
    <Avatar />
  </>
}
```

يحتوي كل مكون من مكونات `<Avatar>` على خطاف `useSWR` بالداخل. نظرا لأن لديهم نفس مفتاح SWR ويتم تقديمه في نفس الوقت تقريبا، **سيتم تقديم طلب شبكة واحد فقط**.

يمكنك إعادة استخدام خطافات البيانات الخاصة بك (مثل "useUser" في المثال أعلاه) في كل مكان، دون القلق بشأن الأداء أو الطلبات المكررة. 
 
هناك أيضا خيار [`dedupingInterval`](/docs/api) لتجاوز الفاصل الزمني الافتراضي للإلغاء المكررة. 
 
## مقارنة عميقة [#مقارنة عميقة] 
 
SWR ** يقارن بعمق ** تغييرات البيانات افتراضيا. إذا لم يتم تغيير قيمة "البيانات"، فلن يتم تشغيل إعادة التصيير. 
 
يمكنك أيضا تخصيص وظيفة المقارنة عبر خيار [`compare`](/docs/api) إذا كنت ترغب في تغيير السلوك. 
على سبيل المثال، ترجع بعض استجابات واجهة برمجة التطبيقات طابعا زمنيا للخادم قد ترغب في استبعاده من فرق البيانات. 
 
## جمع التبعية [#dependency-collection] 
 
ترجع `useSWR` 4 **stateful** قيم: `data` و`error` و`isLoading` و`isValidating`، ويمكن تحديث كل منها بشكل مستقل. 
على سبيل المثال، إذا قمنا بطباعة هذه القيم ضمن دورة حياة كاملة لجلب البيانات، فسيكون الأمر كما يلي:

```jsx
function App () {
  const { data, error, isLoading, isValidating } = useSWR('/api', fetcher)
  console.log(data, error, isLoading, isValidating)
  return null
}
```

في أسوأ الحالات (فشل الطلب الأول، ثم نجحت إعادة المحاولة)، سترى 4 أسطر من السجلات:

```js
// console.log(data, error, isLoading, isValidating)
undefined undefined true true  // => start fetching
undefined Error false false    // => end fetching, got an error
undefined Error true true      // => start retrying
Data undefined false false     // => end retrying, get the data
```

تغييرات الدولة منطقية. ولكن هذا يعني أيضا أن مكوننا **تم تقديمه 4 مرات**. 
 
إذا قمنا بتغيير مكوننا لاستخدام `data` فقط:

```jsx
function App () {
  const { data } = useSWR('/api', fetcher)
  console.log(data)
  return null
}
```

يحدث السحر - لا يوجد سوى **2 إعادة تقديم** الآن:

```js
// console.log(data)
undefined // => hydration / initial render
Data      // => end retrying, get the data
```

حدثت نفس العملية بالضبط داخليا، وكان هناك خطأ من الطلب الأول، ثم حصلنا على البيانات من إعادة المحاولة. رقم 
ومع ذلك، **SWR يقوم فقط بتحديث الحالات التي يستخدمها المكون**، وهو فقط `data` الآن. رقم 
 
إذا كنت لا تستخدم دائما كل هذه الحالات الثلاث، فأنت تستفيد بالفعل من هذه الميزة. رقم 
في [Vercel](https://vercel.com)، يؤدي هذا التحسين إلى إعادة تقديم أقل بنسبة 60٪. رقم 
 
## اهتزاز الشجرة [#هز الشجرة] رقم 
 
حزمة SWR هي [tree-shakeable](https://webpack.js.org/guides/tree-shaking) وخالية من الآثار الجانبية. رقم 
هذا يعني أنه إذا كنت تقوم باستيراد واجهة برمجة التطبيقات الأساسية `useSWR` فقط، فلن يتم تجميع واجهات برمجة التطبيقات غير المستخدمة مثل `useSWRInfinite` في تطبيقك.
