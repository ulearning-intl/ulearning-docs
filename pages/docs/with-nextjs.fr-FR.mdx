import { Callout } from 'nextra-theme-docs'

Êú∫Áøª
# Utilisation avec Next.js 

## Routeur d'application [#app-dir] 

### Composants du serveur [#rsc]


<Callout type="default" emoji="‚úÖ">
 Dans Next.js App Router, tous les composants sont React Server Components (RSC) par d√©faut. **Vous ne pouviez importer que les API de s√©rialisation des cl√©s √† partir de SWR dans RSC.**
</Callout>

```tsx filename="app/page.tsx" copy
import { unstable_serialize } from 'swr' // ‚úÖ Available in server components
import { unstable_serialize as infinite_unstable_serialize } from 'swr/infinite' // ‚úÖ Available in server components
```

<Callout type="error">
  Vous ne pouvez pas importer d'autres API de SWR car elles ne sont pas disponibles dans RSC.
</Callout>

```tsx filename="app/page.tsx" highlight={1}
import useSWR from 'swr' // ‚ùå This is not available in server components
```

### Composants clients 

Vous pouvez marquer vos composants avec la directive `"use client"` ou importer SWR √† partir de composants client, les deux fa√ßons vous permettront d'utiliser les crochets de r√©cup√©ration de donn√©es client SWR.

```tsx filename="app/page.tsx" highlight={1} copy
'use client'
import useSWR from 'swr'
export default Page() {
  const { data } = useSWR('/api/user', fetcher)
  return <h1>{data.name}</h1>
}
```

Si vous avez besoin d'utiliser `SWRConfig` pour configurer les param√®tres globaux dans les composants du serveur `layout` ou `page`, en cr√©ant un composant client fournisseur distinct pour configurer le fournisseur et la configuration, puis utilisez-le dans les pages des composants du serveur.

```tsx filename="app/swr-provider.tsx" copy
'use client';
import { SWRConfig } from 'swr'
export const SWRProvider = ({ children }) => {
  return <SWRConfig>{children}</SWRConfig>
};
```

```tsx filename="app/page.tsx" copy
// This is still a server component
import { SWRProvider } from './swr-provider'
export default Page() {
  return (
    <SWRProvider>
      <h1>hello SWR</h1>
    </SWRProvider>
  )
}
```


## R√©cup√©ration des donn√©es c√¥t√© client [#client-side-data-fetching] 

Si votre page contient des donn√©es fr√©quemment mises √† jour, et que vous n'avez pas besoin de pr√©-rendu les donn√©es, SWR est un ajustement parfait et aucune configuration sp√©ciale n'est n√©cessaire : il suffit d'importer `useSWR` et d'utiliser le crochet √† l'int√©rieur de tous les composants qui utilisent les donn√©es. 
 
Voici comment cela fonctionne : 

- Tout d'abord, affichez imm√©diatement la page sans donn√©es. Vous pouvez afficher les √©tats de chargement des donn√©es manquantes. 
- Ensuite, r√©cup√©rez les donn√©es du c√¥t√© client et affichez-les lorsque vous √™tes pr√™t. 
 
Cette approche fonctionne bien pour les pages de tableau de bord des utilisateurs, par exemple. √âtant donn√© qu'un tableau de bord est une page priv√©e et sp√©cifique √† l'utilisateur, le r√©f√©rencement n'est pas pertinent et la page n'a pas besoin d'√™tre pr√©-rendue. Les donn√©es sont fr√©quemment mises √† jour, ce qui n√©cessite la r√©cup√©ration des donn√©es au moment de la demande. 

## Pr√©-rendu avec des donn√©es par d√©faut [#pr√©-rendu avec-donn√©es par d√©faut] 
 
Si la page doit √™tre pr√©-rendu, Next.js prend en charge [2 formes de pr√©-rendu](https://nextjs.org/docs/basic-features/data-fetching) : 
**Gn g√©n√©ration statique (SSG)** et **Renrage c√¥t√© serveur (SSR)**. 
 
Avec SWR, vous pouvez pr√©-rendu la page pour le r√©f√©rencement, et √©galement avoir des fonctionnalit√©s telles que la mise en cache, la revalidation, le suivi de la mise au point, la re-forte sur l'intervalle du c√¥t√© client. 
 
Vous pouvez utiliser l'option `fallback` de [`SWRConfig`](/docs/global-configuration) pour passer les donn√©es pr√©-retched comme valeur initiale de tous les crochets SWR. 
 
Par exemple avec `getStaticProps` :

```jsx
 export async function getStaticProps () {
  // `getStaticProps` is executed on the server side.
  const article = await getArticleFromAPI()
  return {
    props: {
      fallback: {
        '/api/article': article
      }
    }
  }
}

function Article() {
  // `data` will always be available as it's in `fallback`.
  const { data } = useSWR('/api/article', fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  // SWR hooks inside the `SWRConfig` boundary will use those values.
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```

La page est toujours pr√©-rendue. Il est convivial pour le r√©f√©rencement, rapide √† r√©pondre, mais aussi enti√®rement aliment√© par SWR du c√¥t√© du client. Les donn√©es peuvent √™tre dynamiques et auto-mises √† jour au fil du temps.

<Callout emoji="üí°">
  Le composant `Article` rendra d'abord les donn√©es pr√©-g√©n√©r√©es, et une fois la page hydrat√©e, il r√©cup√©rera √† nouveau les derni√®res donn√©es pour les maintenir actualis√©es.
</Callout>

### Cl√©s complexes [#cl√©s complexes]

`useSWR` peut √™tre utilis√© avec des cl√©s qui sont de type `array` et `function`. L'utilisation de donn√©es pr√©-r√©cup√©es avec ce type de cl√©s n√©cessite la s√©rialisation des cl√©s `fallback` avec `unstable_serialize`.

```jsx
import useSWR, { unstable_serialize } from 'swr'

export async function getStaticProps () {
  const article = await getArticleFromAPI(1)
  return {
    props: {
      fallback: {
        // unstable_serialize() array style key
        [unstable_serialize(['api', 'article', 1])]: article,
      }
    }
  }
}

function Article() {
  // using an array style key.
  const { data } = useSWR(['api', 'article', 1], fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```
