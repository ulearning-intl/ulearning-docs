---
image: https://assets.vercel.com/image/upload/v1670542323/swr/v2.png
description: 'الإعلان عن SWR 2.0: واجهات برمجة تطبيقات طفرة جديدة وقدرات واجهة مستخدم متفائلة محسنة، وأدوات تطوير جديدة، ودعم أفضل للعرض المتزامن، والمزيد.'
date: December 9th, 2022
---

import { Callout } from 'nextra-theme-docs'
import { Bleed } from 'nextra-theme-docs'

import Authors, { Author } from 'components/authors'
import Video from 'components/video'

机翻
# الإعلان عن SWR 2.0 [#announcing-swr-20]

<Authors date="December 9th, 2022">
  <Author name="Shu Ding" link="https://twitter.com/shuding_" />
  <Author name="Jiachi Liu" link="https://twitter.com/huozhi" />
  <Author name="Toru Kobayashi" link="https://twitter.com/koba04" />
  <Author name="Yixuan Xu" link="https://twitter.com/yixuanxu94" />
</Authors>

يسعدنا أن نعلن عن إصدار SWR 2.0، مكتبة جلب بيانات React الشهيرة التي تمكن المكونات من جلب البيانات وتخزينها مؤقتا وتحويلها وتبقي واجهة المستخدم محدثة مع التغييرات في تلك البيانات بمرور الوقت. رقم 

يأتي هذا الإصدار الجديد مليئا بالتحسينات والميزات الجديدة، مثل واجهات برمجة تطبيقات الطفرات الجديدة، وقدرات واجهة المستخدم المتفائلة المحسنة، وأدوات التطوير الجديدة، ودعم أفضل للعرض المتزامن. نود أن نتقدم بشكرنا الجزيل لجميع المساهمين والمحافظين الذين جعلوا هذا الإصدار ممكنا.

## الطفرة وواجهة المستخدم المتفائلة [#طفرة وواجهة مستخدم متفائلة] 

### استخدم SWRMutation [#استخدام swrmation]

الطفرة هي جزء مهم من عملية جلب البيانات. إنها تسمح لك بإجراء تغييرات على بياناتك محليا وعن بعد. تسمح لك واجهة برمجة تطبيقات "mutate" الحالية بإعادة التحقق من الموارد وتحورها يدويا. في SWR 2.0، يجعل الخطاف الجديد "useSWRMutation" من السهل تغيير البيانات عن بعد باستخدام واجهة برمجة تطبيقات إعلانية. يمكنك إعداد طفرة باستخدام الخطاف، ثم تنشيطها لاحقا:

```jsx {11,16}
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  })
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest)

  return (
    <button
      disabled={isMutating}
      onClick={() => trigger({ username: 'johndoe' })}
    >{
      isMutating ? 'Creating...' : 'Create User'
    }</button>
  )
}
```

يحدد المثال أعلاه طفرة `sendRequest` التي تؤثر على مورد `'/api/user'` على عكس `useSWR`، لن يبدأ `useSWRMutation` الطلب على الفور عند التقديم. بدلا من ذلك، فإنه يعيد وظيفة `trigger` التي يمكن استدعاؤها لاحقا لبدء الطفرة يدويا. رقم 
 
سيتم استدعاء وظيفة `sendRequest` عند النقر فوق الزر، مع الوسيطة الإضافية `{ username: 'johndoe' }`. سيتم تعيين قيمة `isMutating` على `true` حتى تنتهي الطفرة. رقم 
 
بالإضافة إلى ذلك، يعالج هذا الخطاف الجديد مشكلات أخرى قد تكون لديك مع الطفرات: رقم 
 
 - قم بتحديث واجهة المستخدم بتفاؤل أثناء تحور البيانات رقم 
 - العودة تلقائيا عندما تفشل الطفرة رقم 
 - تجنب أي ظروف عرق محتملة بين `useSWR` والطفرات الأخرى من نفس المورد رقم 
 - ملء ذاكرة التخزين المؤقت `useSWR` بعد اكتمال الطفرة رقم 
 - ...

يمكنك العثور على مراجع وأمثلة متعمقة لواجهة برمجة التطبيقات عن طريق قراءة [docs](/docs/mutation#useswrmutation) أو التمرير عبر الأقسام القليلة التالية. رقم 
 
### واجهة مستخدم متفائلة  رقم [#واجهة المستخدم المتفائلة]
 
واجهة المستخدم المتفائلة هي نموذج ممتاز لإنشاء مواقع ويب تشعر بالسرعة والاستجابة؛ ومع ذلك، قد يكون من الصعب تنفيذها بشكل صحيح. أضاف SWR 2.0 بعض الخيارات القوية الجديدة لتسهيل الأمر. رقم 
 
لنفترض أن لدينا واجهة برمجة تطبيقات تضيف مهام جديدة إلى قائمة المهام وترسلها إلى الخادم:

```jsx
await addNewTodo('New Item')
```

في واجهة المستخدم الخاصة بنا، نستخدم خطاف `useSWR` لعرض قائمة المهام، مع زر "إضافة عنصر جديد" الذي يقوم بتشغيل هذا الطلب ويطلب من SWR إعادة جلب البيانات عبر `mutate()`:

```jsx {7,8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={async () => {
    await addNewTodo('New Item')
    mutate()
  }}>
    Add New Item
  </button>
</>
```

ومع ذلك، قد يكون طلب `await addNewTodo(...)` بطيئا جدا. عندما تكون مستمرة، لا يزال المستخدمون يرون القائمة القديمة حتى لو استطعنا بالفعل معرفة شكل القائمة الجديدة. باستخدام خيار "البيانات المتفائلة" الجديد، يمكننا إظهار القائمة الجديدة بتفاؤل، قبل أن يستجيب الخادم:

```jsx {8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
    })
  }}>
    Add New Item
  </button>
</>
```

ستقوم SWR على الفور بتحديث `data` بقيمة `optimisticData`، ثم ترسل الطلب إلى الخادم. بمجرد انتهاء الطلب، ستعيد SWR التحقق من صحة المورد للتأكد من أنه الأحدث. 
 
مثل العديد من واجهات برمجة التطبيقات، إذا أعاد لنا طلب `addNewTodo(...)` أحدث البيانات من الخادم، فيمكننا إظهار هذه النتيجة مباشرة أيضا (بدلا من بدء إعادة التحقق من صح جديدة)! هناك خيار "populateCache" الجديد لإخبار SWR بتحديث البيانات المحلية باستجابة الطفرة:

```jsx {9}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
      populateCache: true,
    })
  }}>
    Add New Item
  </button>
</>
```

في الوقت نفسه، لا نحتاج إلى إعادة التحقق من صحة أخرى بعد ذلك لأن بيانات الاستجابة من مصدر الحقيقة، يمكننا تعطيلها باستخدام خيار `revalidate`:

```jsx {10}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
      populateCache: true,
      revalidate: false,
    })
  }}>
    Add New Item
  </button>
</>
```

أخيرا، إذا فشل `addNewTodo(...)` باستثناء، فيمكننا إرجاع البيانات المتفائلة (`[...data, 'New Item']`) التي قمنا بتعيينها للتو، عن طريق تعيين `rollbackOnError` على `true` (وهو أيضا الخيار الافتراضي). عندما يحدث ذلك، ستتراجع SWR `data` إلى القيمة السابقة.

```jsx {11}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
      populateCache: true,
      revalidate: false,
      rollbackOnError: true,
    })
  }}>
    Add New Item
  </button>
</>
```

يتم دعم جميع واجهات برمجة التطبيقات هذه في خطاف `useSWRMutation` الجديد أيضا. لمعرفة المزيد عنها، يمكنك التحقق من [docs](/docs/mutation#optimistic-updates). وإليك عرض توضيحي يوضح هذا السلوك:

<Video
  src="/video/optimistic-ui.mp4"
  caption="Optimistic UI with automatic error rollback"
  ratio={223/584}
/>

### كتم مفاتيح متعددة [#مفاتيح متعددة الطفرات] 

تقبل واجهة برمجة التطبيقات العالمية "تحور" الآن وظيفة الفلتر، حيث يمكنك تغيير مفاتيح محددة أو إعادة التحقق من صواها. سيكون هذا مفيدا لحالات الاستخدام مثل إبطال جميع البيانات المخزنة مؤقتا. لمعرفة المزيد، يمكنك قراءة [تحور مفاتيح متعددة](/docs/mutation#mutate-multiple-items) في المستندات.

```jsx
import { mutate } from 'swr'
// Or from the hook if you have customized your cache provider:
// { mutate } = useSWRConfig()

// Mutate single resource
mutate(key)

// Mutate multiple resources and clear the cache (set to undefined)
mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: false }
)
```

## أدوات تطوير SWR  رقم [#swr-devtools]

[SWRDevTools](https://swr-devtools.vercel.app) هو امتداد متصفح يساعدك على تصحيح ذاكرة التخزين المؤقت SWR ونتائج الجلب. تحقق من قسم [devtools](/docs/advanced/devtools) لمعرفة كيفية استخدام devtools في تطبيقك. رقم 
![]( /Img/devtools/cache-view.jpg) رقم 

## التحميل المسبق للبيانات  رقم [#preloading-data]

يمكن أن يؤدي التحميل المسبق للبيانات إلى تحسين تجربة المستخدم بشكل كبير. إذا كنت تعرف أنه سيتم استخدام المورد لاحقا في التطبيق، فيمكنك استخدام واجهة برمجة التطبيقات الجديدة "التحميل المسبق" لبدء جلبه مبكرا:

```jsx {6}
import useSWR, { preload } from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

// You can call the preload function in anywhere
preload('/api/user', fetcher)

function Profile() {
  // The component that actually uses the data:
  const { data, error } = useSWR('/api/user', fetcher)
  // ...
}

export function Page () {
  return <Profile/>
}
```

في هذا المثال، يتم استدعاء واجهة برمجة التطبيقات `preload` في النطاق العالمي. هذا يعني أننا نبدأ في التحميل المسبق للمورد قبل أن تبدأ React في تقديم أي شيء. 
 وعندما يتم تقديم مكون "الملف الشخصي"، من المحتمل أن تكون البيانات متاحة بالفعل. إذا كان لا يزال مستمرا، فسيعيد خطاف `useSWR` استخدام طلب التحميل المسبق المستمر بدلا من بدء طلب جديد. 
 
يمكن أيضا استخدام واجهة برمجة تطبيقات `preload` في حالات مثل بيانات التحميل المسبق لصفحة أخرى من المحتمل تقديمها. يمكن العثور على مزيد من المعلومات حول الجلب المسبق للبيانات باستخدام SWR [هنا](/docs/prefetching).

## `isLoading` رقم  [#isloading]

`isLoading` هي حالة جديدة تم إرجاعها بواسطة `useSWR`، تشير إلى **إذا كان الطلب لا يزال مستمرا، ولا توجد بيانات تم تحميلها حتى الآن**. في السابق، تمثل حالة `isValidating` كل من حالة التحميل الأولية وحالة إعادة التحقق من الصحة، لذلك كان علينا التحقق مما إذا كان كل من `data` و"`error` `undefined` لتحديد ما إذا كانت حالة التحميل الأولية. رقم 
 
الآن، من السهل جدا أن تتمكن من استخدام قيمة `isLoading` مباشرة لتقديم رسالة تحميل:

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, isLoading } = useSWR('/api/user', fetcher)

  if (isLoading) return <div>loading...</div>
  return <div>hello {data.name}!</div>
}
```

لاحظ أن `isValidating` لا يزال موجودا حتى تتمكن من استخدامه لإظهار مؤشر تحميل لإعادة التحقق من هويته.

<Callout emoji="📝">
  لقد أضفنا صفحة [فهم SWR] (/docs/advanced/understanding) الجديدة لوصف كيفية إرجاع SWR للقيم، والتي تشمل الفرق بين `isValidating` و `isLoading`، وكيفية دمجها لتحسين تجربة المستخدم.
</Callout>

## الحفاظ على الحالة السابقة [#الحفاظ على الحالة السابقة] 

 خيار `keepPreviousData` هو إضافة جديدة تسمح لك بالاحتفاظ بالبيانات التي تم جلبها من قبل. يعمل هذا على تحسين تجربة المستخدم بشكل كبير عند جلب البيانات استنادا إلى إجراءات المستخدم التي تحدث في الوقت الفعلي، كما هو الحال مع ميزة البحث المباشر، حيث يستمر `key` للمورد في التغير:

```jsx {5}
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  })

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="احتفظ بنتائج البحث السابقة عند تمكين keepPreviousData"
  ratio={640/730}
/>

تحقق من الرمز على [CodeSandbox](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m) ويمكنك قراءة المزيد عنه [هنا](/docs/advanced/understanding#return-previous-data-for-better-ux). رقم 

## تمديد التكوينات  رقم [#extending-configurations]
 
يمكن ل `SWRConfig` الآن قبول قيمة دالة. عندما يكون لديك مستويات متعددة من "، يتلقى الجزء الداخلي التكوين الأصلي ويعيد تكوينا جديدا. هذا التغيير يجعل الأمر أكثر مرونة لتكوين SWR في قاعدة رموز كبيرة. يمكن العثور على مزيد من المعلومات [هنا](/docs/global-configuration).

```jsx
<SWRConfig
  value={parentConfig => ({
    dedupingInterval: parentConfig.dedupingInterval * 5,
    refreshInterval: 100,
  })}
>
  <Page />
</SWRConfig>
```

## تحسين دعم React 18 [#improved-react-18-support] 

قامت SWR بتحديث التعليمات البرمجية الداخلية الخاصة بها لاستخدام واجهات برمجة التطبيقات `useSyncExternalStore` و`startTransition` في React 18. هذه تضمن اتساقا أقوى عند تقديم واجهة المستخدم في وقت واحد. لا يتطلب هذا التغيير أي تغييرات في رمز المستخدم وسيستفيد منه جميع المطورين مباشرة. يتم تضمين الحشوات في React 17 وأدناه. 
 
لا يزال SWR 2.0 وجميع الميزات الجديدة متوافقة مع React 16 و17. 

## دليل الهجرة [#دليل الهجرة]


### Fetcher لم يعد يقبل حججا متعددة [#fetcher-no-longer-accepts-multiple-arguments] 
 
تم تمرير `key` الآن كحجة واحدة.


```diff
- useSWR([1, 2, 3], (a, b, c) => {
+ useSWR([1, 2, 3], ([a, b, c]) => {
  assert(a === 1)
  assert(b === 2)
  assert(c === 3)
})
```

### Global Mutate لم يعد يقبل وظيفة `getKey` [#global-mutate-no-longer-accepts-a-getkey-function] 
 
الآن، إذا قمت بتمرير وظيفة إلى `mutate` العالمية، فسيتم استخدامها ك [مرشح](/blog/swr-v2#mutate-multiple-keys). في السابق، يمكنك تمرير دالة ترجع مفتاحا إلى `mutate` العالمي:

```diff
- mutate(() => '/api/item') // a function to return a key
+ mutate('/api/item')       // to mutate the key, directly pass it
```

### خاصية جديدة مطلوبة `keys()` لواجهة ذاكرة التخزين المؤقت [#new-required-property-keys-for-cache-interface] 
 
عند استخدام تنفيذ ذاكرة التخزين المؤقت الخاصة بك، تتطلب واجهة ذاكرة التخزين المؤقت الآن طريقة `keys()` التي ترجع جميع المفاتيح في كائن ذاكرة التخزين المؤقت، على غرار مثيلات خريطة جافا سكريبت.

```diff
interface Cache<Data> {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
+ keys(): IterableIterator<string>
}
```

### تم تغيير الهيكل الداخلي لذاكرة التخزين المؤقت [#changed-cache-internal-structure] 
 
سيكون الهيكل الداخلي لبيانات ذاكرة التخزين المؤقت كائنا يحمل جميع الحالات الحالية.

```diff
- assert(cache.get(key) === data)
+ assert(cache.get(key) === { data, error, isValidating })

// getter
- cache.get(key)
+ cache.get(key)?.data

// setter
- cache.set(key, data)
+ cache.set(key, { ...cache.get(key), data })
```

<Callout emoji="🚨" type="error">
 يجب ألا تكتب إلى ذاكرة التخزين المؤقت مباشرة، فقد يتسبب ذلك في سلوك غير محدد.
</Callout>

### تمت إعادة تسمية `SWRConfig.default` باسم `SWRConfig.defaultValue`  رقم [#swrconfigdefault-is-renamed-as-swrconfigdefaultvalue]
 
`SWRconfig.defaultValue` هي خاصية الوصول إلى تكوين SWR الافتراضي.

```diff
- SWRConfig.default
+ SWRConfig.defaultValue
```

### نوع `InfiniteFetcher` تمت إعادة تسميته باسم `SWRInfiniteFetcher` [#type-infinitefetcher-is-renamed-as-swrinfinitefetcher]

```diff
- import type { InfiniteFetcher } from 'swr/infinite'
+ import type { SWRInfiniteFetcher } from 'swr/infinite'
```

### تجنب التشويق على الخادم [#تجنب التشويق على الخادم] 
 
إذا كنت ترغب في استخدام `suspense: true` مع SWR على جانب الخادم، بما في ذلك التقديم المسبق في Next.js، فيجب عليك تقديم البيانات الأولية عبر [`fallbackData` أو `fallback`](/docs/with-nextjs#pre-rendering-with-default-data). اليوم، هذا يعني أنه لا يمكنك استخدام Suspense لجلب البيانات على جانب الخادم. يقوم الخياران الآخران بجلب البيانات بالكامل من جانب العميل أو الحصول على إطار العمل الخاص بك لجلب البيانات نيابة عنك (كما يفعل getStaticProps في Next.js). 
 
### ES2018 كهدف للبناء [#es2018-as-the-build-target] 
 
إذا كنت ترغب في دعم IE 11، فيجب عليك استهداف ES5 في إطار العمل الخاص بك أو حزمة. أدى هذا التغيير إلى تحسين الأداء في SSR، ويحافظ على حجم الحزمة صغيرا. 
 
## سجل التغيير [#changelog] 
 
اقرأ سجل التغيير الكامل [على GitHub](https://github.com/vercel/swr/releases). 
 
## المستقبل وشكرا لك! [#المستقبل--شكرا لك] 
 
مع الإصدار الجديد من [Next.js 13](https://nextjs.org/blog/next-13)، نرى الكثير من الأشياء الجديدة المثيرة بالإضافة إلى التحولات النموذجية في النظام البيئي React:[React Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components), streaming SSR, [async components](https://beta.nextjs.org/docs/data-fetching/fetching#asyncawait-in-server-components)وخطاف [`use` hook](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#usepromise).يرتبط العديد منها بجلب البيانات، وبعضها يحتوي على حالات استخدام متداخلة مع SWR.
 
ومع ذلك، لا يزال هدف مشروع SWR كما هو. نريدها أن تكون مكتبة منسدلة وخفيفة الوزن ولاأدرية للإطار وقليلا من _opinionated_ (أي إعادة التحقق من التركيز). بدلا من محاولة أن نكون حلا قياسيا، نريد التركيز على الابتكارات التي تجعل تجربة المستخدم أفضل. في غضون ذلك، نقوم أيضا بإجراء أبحاث حول كيفية تحسين SWR باستخدام هذه القدرات الجديدة ل React. 
 
نود أن نشكر كل واحد من المساهمين في المستندات [143](https://github.com/vercel/swr/graphs/contributors) (+ [106](https://github.com/vercel/swr-site/graphs/contributors)المساهمون في المستندات)،وكذلك أولئك الذين يساعدوننا أو يقدمون تعليقات. شكر خاص إلى [تورو كوباياشي](https://twitter.com/koba04) على كل عمله على أدوات التطوير والمستندات - لم نكن لنفعل ذلك بدونك!
